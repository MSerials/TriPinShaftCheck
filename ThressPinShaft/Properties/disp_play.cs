//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//
//  This file is intended to be used with the HDevelopTemplate or
//  HDevelopTemplateWPF projects located under %HALCONEXAMPLES%\c#

using System;
using System.Windows;
using HalconDotNet;

public partial class HDevelopExportDisp
{
    public HTuple hv_ExpDefaultWinHandle;
    HTuple w = 0, h = 0,pointer_, type_;
    // Main procedure 
    private void action(HObject ho_Image)
    {
        //HOperatorSet.GenEmptyObj(out ho_Image);
        try
        {
            //HOperatorSet.SetDraw(hv_ExpDefaultWinHandle,"margin");
            HOperatorSet.GetImagePointer1(ho_Image, out pointer_, out type_, out w, out h);
            HOperatorSet.SetPart(hv_ExpDefaultWinHandle,0,0,h,w);
            HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);
        }catch(HalconException HDevExpDefaultException)
        {
            ho_Image.Dispose();
            throw HDevExpDefaultException;
        }
    }

    public void disp_continue_message(HTuple hv_WindowHandle, HTuple hv_Color, HTuple hv_Box)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_ContinueMessage = null, hv_Row = null;
        HTuple hv_Column = null, hv_Width = null, hv_Height = null;
        HTuple hv_Ascent = null, hv_Descent = null, hv_TextWidth = null;
        HTuple hv_TextHeight = null;
        // Initialize local and output iconic variables 
        //This procedure displays 'Press Run (F5) to continue' in the
        //lower right corner of the screen.
        //It uses the procedure disp_message.
        //
        //Input parameters:
        //WindowHandle: The window, where the text shall be displayed
        //Color: defines the text color.
        //   If set to '' or 'auto', the currently set color is used.
        //Box: If set to 'true', the text is displayed in a box.
        //
        hv_ContinueMessage = "Press Run (F5) to continue";
        HOperatorSet.GetWindowExtents(hv_ExpDefaultWinHandle, out hv_Row, out hv_Column,
            out hv_Width, out hv_Height);
        HOperatorSet.GetStringExtents(hv_ExpDefaultWinHandle, (" " + hv_ContinueMessage) + " ",
            out hv_Ascent, out hv_Descent, out hv_TextWidth, out hv_TextHeight);
        disp_message(hv_ExpDefaultWinHandle, hv_ContinueMessage, "window", (hv_Height - hv_TextHeight) - 12,
            (hv_Width - hv_TextWidth) - 12, hv_Color, hv_Box);

        return;
    }

    // Chapter: Graphics / Text
    // Short Description: Set font independent of OS 
    public void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font,
        HTuple hv_Bold, HTuple hv_Slant)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_OS = null, hv_BufferWindowHandle = new HTuple();
        HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
        HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
        HTuple hv_Scale = new HTuple(), hv_Exception = new HTuple();
        HTuple hv_SubFamily = new HTuple(), hv_Fonts = new HTuple();
        HTuple hv_SystemFonts = new HTuple(), hv_Guess = new HTuple();
        HTuple hv_I = new HTuple(), hv_Index = new HTuple(), hv_AllowedFontSizes = new HTuple();
        HTuple hv_Distances = new HTuple(), hv_Indices = new HTuple();
        HTuple hv_FontSelRegexp = new HTuple(), hv_FontsCourier = new HTuple();
        HTuple hv_Bold_COPY_INP_TMP = hv_Bold.Clone();
        HTuple hv_Font_COPY_INP_TMP = hv_Font.Clone();
        HTuple hv_Size_COPY_INP_TMP = hv_Size.Clone();
        HTuple hv_Slant_COPY_INP_TMP = hv_Slant.Clone();

        // Initialize local and output iconic variables 
        //This procedure sets the text font of the current window with
        //the specified attributes.
        //It is assumed that following fonts are installed on the system:
        //Windows: Courier New, Arial Times New Roman
        //Mac OS X: CourierNewPS, Arial, TimesNewRomanPS
        //Linux: courier, helvetica, times
        //Because fonts are displayed smaller on Linux than on Windows,
        //a scaling factor of 1.25 is used the get comparable results.
        //For Linux, only a limited number of font sizes is supported,
        //to get comparable results, it is recommended to use one of the
        //following sizes: 9, 11, 14, 16, 20, 27
        //(which will be mapped internally on Linux systems to 11, 14, 17, 20, 25, 34)
        //
        //Input parameters:
        //WindowHandle: The graphics window for which the font will be set
        //Size: The font size. If Size=-1, the default of 16 is used.
        //Bold: If set to 'true', a bold font is used
        //Slant: If set to 'true', a slanted font is used
        //
        HOperatorSet.GetSystem("operating_system", out hv_OS);
        // dev_get_preferences(...); only in hdevelop
        // dev_set_preferences(...); only in hdevelop
        if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
            new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
        {
            hv_Size_COPY_INP_TMP = 16;
        }
        if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
        {
            //Set font on Windows systems
            try
            {
                //Check, if font scaling is switched on
                //open_window(...);
                HOperatorSet.SetFont(hv_ExpDefaultWinHandle, "-Consolas-16-*-0-*-*-1-");
                HOperatorSet.GetStringExtents(hv_ExpDefaultWinHandle, "test_string", out hv_Ascent,
                    out hv_Descent, out hv_Width, out hv_Height);
                //Expected width is 110
                hv_Scale = 110.0 / hv_Width;
                hv_Size_COPY_INP_TMP = ((hv_Size_COPY_INP_TMP * hv_Scale)).TupleInt();
                //close_window(...);
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                //throw (Exception)
            }
            if ((int)((new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))).TupleOr(
                new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("courier")))) != 0)
            {
                hv_Font_COPY_INP_TMP = "Courier New";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
            {
                hv_Font_COPY_INP_TMP = "Consolas";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
            {
                hv_Font_COPY_INP_TMP = "Arial";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
            {
                hv_Font_COPY_INP_TMP = "Times New Roman";
            }
            if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("true"))) != 0)
            {
                hv_Bold_COPY_INP_TMP = 1;
            }
            else if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("false"))) != 0)
            {
                hv_Bold_COPY_INP_TMP = 0;
            }
            else
            {
                hv_Exception = "Wrong value of control parameter Bold";
                throw new HalconException(hv_Exception);
            }
            if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("true"))) != 0)
            {
                hv_Slant_COPY_INP_TMP = 1;
            }
            else if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("false"))) != 0)
            {
                hv_Slant_COPY_INP_TMP = 0;
            }
            else
            {
                hv_Exception = "Wrong value of control parameter Slant";
                throw new HalconException(hv_Exception);
            }
            try
            {
                HOperatorSet.SetFont(hv_ExpDefaultWinHandle, ((((((("-" + hv_Font_COPY_INP_TMP) + "-") + hv_Size_COPY_INP_TMP) + "-*-") + hv_Slant_COPY_INP_TMP) + "-*-*-") + hv_Bold_COPY_INP_TMP) + "-");
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                //throw (Exception)
            }
        }
        else if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Dar"))) != 0)
        {
            //Set font on Mac OS X systems. Since OS X does not have a strict naming
            //scheme for font attributes, we use tables to determine the correct font
            //name.
            hv_SubFamily = 0;
            if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("true"))) != 0)
            {
                hv_SubFamily = hv_SubFamily.TupleBor(1);
            }
            else if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleNotEqual("false"))) != 0)
            {
                hv_Exception = "Wrong value of control parameter Slant";
                throw new HalconException(hv_Exception);
            }
            if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("true"))) != 0)
            {
                hv_SubFamily = hv_SubFamily.TupleBor(2);
            }
            else if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleNotEqual("false"))) != 0)
            {
                hv_Exception = "Wrong value of control parameter Bold";
                throw new HalconException(hv_Exception);
            }
            if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
            {
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "Menlo-Regular";
                hv_Fonts[1] = "Menlo-Italic";
                hv_Fonts[2] = "Menlo-Bold";
                hv_Fonts[3] = "Menlo-BoldItalic";
            }
            else if ((int)((new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))).TupleOr(
                new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("courier")))) != 0)
            {
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "CourierNewPSMT";
                hv_Fonts[1] = "CourierNewPS-ItalicMT";
                hv_Fonts[2] = "CourierNewPS-BoldMT";
                hv_Fonts[3] = "CourierNewPS-BoldItalicMT";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
            {
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "ArialMT";
                hv_Fonts[1] = "Arial-ItalicMT";
                hv_Fonts[2] = "Arial-BoldMT";
                hv_Fonts[3] = "Arial-BoldItalicMT";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
            {
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "TimesNewRomanPSMT";
                hv_Fonts[1] = "TimesNewRomanPS-ItalicMT";
                hv_Fonts[2] = "TimesNewRomanPS-BoldMT";
                hv_Fonts[3] = "TimesNewRomanPS-BoldItalicMT";
            }
            else
            {
                //Attempt to figure out which of the fonts installed on the system
                //the user could have meant.
                HOperatorSet.QueryFont(hv_ExpDefaultWinHandle, out hv_SystemFonts);
                hv_Fonts = new HTuple();
                hv_Fonts = hv_Fonts.TupleConcat(hv_Font_COPY_INP_TMP);
                hv_Fonts = hv_Fonts.TupleConcat(hv_Font_COPY_INP_TMP);
                hv_Fonts = hv_Fonts.TupleConcat(hv_Font_COPY_INP_TMP);
                hv_Fonts = hv_Fonts.TupleConcat(hv_Font_COPY_INP_TMP);
                hv_Guess = new HTuple();
                hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP);
                hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP + "-Regular");
                hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP + "MT");
                for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_Guess.TupleLength())) - 1); hv_I = (int)hv_I + 1)
                {
                    HOperatorSet.TupleFind(hv_SystemFonts, hv_Guess.TupleSelect(hv_I), out hv_Index);
                    if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
                    {
                        if (hv_Fonts == null)
                            hv_Fonts = new HTuple();
                        hv_Fonts[0] = hv_Guess.TupleSelect(hv_I);
                        break;
                    }
                }
                //Guess name of slanted font
                hv_Guess = new HTuple();
                hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP + "-Italic");
                hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP + "-ItalicMT");
                hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP + "-Oblique");
                for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_Guess.TupleLength())) - 1); hv_I = (int)hv_I + 1)
                {
                    HOperatorSet.TupleFind(hv_SystemFonts, hv_Guess.TupleSelect(hv_I), out hv_Index);
                    if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
                    {
                        if (hv_Fonts == null)
                            hv_Fonts = new HTuple();
                        hv_Fonts[1] = hv_Guess.TupleSelect(hv_I);
                        break;
                    }
                }
                //Guess name of bold font
                hv_Guess = new HTuple();
                hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP + "-Bold");
                hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP + "-BoldMT");
                for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_Guess.TupleLength())) - 1); hv_I = (int)hv_I + 1)
                {
                    HOperatorSet.TupleFind(hv_SystemFonts, hv_Guess.TupleSelect(hv_I), out hv_Index);
                    if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
                    {
                        if (hv_Fonts == null)
                            hv_Fonts = new HTuple();
                        hv_Fonts[2] = hv_Guess.TupleSelect(hv_I);
                        break;
                    }
                }
                //Guess name of bold slanted font
                hv_Guess = new HTuple();
                hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP + "-BoldItalic");
                hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP + "-BoldItalicMT");
                hv_Guess = hv_Guess.TupleConcat(hv_Font_COPY_INP_TMP + "-BoldOblique");
                for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_Guess.TupleLength())) - 1); hv_I = (int)hv_I + 1)
                {
                    HOperatorSet.TupleFind(hv_SystemFonts, hv_Guess.TupleSelect(hv_I), out hv_Index);
                    if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
                    {
                        if (hv_Fonts == null)
                            hv_Fonts = new HTuple();
                        hv_Fonts[3] = hv_Guess.TupleSelect(hv_I);
                        break;
                    }
                }
            }
            hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(hv_SubFamily);
            try
            {
                HOperatorSet.SetFont(hv_ExpDefaultWinHandle, (hv_Font_COPY_INP_TMP + "-") + hv_Size_COPY_INP_TMP);
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                //throw (Exception)
            }
        }
        else
        {
            //Set font for UNIX systems
            hv_Size_COPY_INP_TMP = hv_Size_COPY_INP_TMP * 1.25;
            hv_AllowedFontSizes = new HTuple();
            hv_AllowedFontSizes[0] = 11;
            hv_AllowedFontSizes[1] = 14;
            hv_AllowedFontSizes[2] = 17;
            hv_AllowedFontSizes[3] = 20;
            hv_AllowedFontSizes[4] = 25;
            hv_AllowedFontSizes[5] = 34;
            if ((int)(new HTuple(((hv_AllowedFontSizes.TupleFind(hv_Size_COPY_INP_TMP))).TupleEqual(
                -1))) != 0)
            {
                hv_Distances = ((hv_AllowedFontSizes - hv_Size_COPY_INP_TMP)).TupleAbs();
                HOperatorSet.TupleSortIndex(hv_Distances, out hv_Indices);
                hv_Size_COPY_INP_TMP = hv_AllowedFontSizes.TupleSelect(hv_Indices.TupleSelect(
                    0));
            }
            if ((int)((new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))).TupleOr(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(
                "Courier")))) != 0)
            {
                hv_Font_COPY_INP_TMP = "courier";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
            {
                hv_Font_COPY_INP_TMP = "helvetica";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
            {
                hv_Font_COPY_INP_TMP = "times";
            }
            if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("true"))) != 0)
            {
                hv_Bold_COPY_INP_TMP = "bold";
            }
            else if ((int)(new HTuple(hv_Bold_COPY_INP_TMP.TupleEqual("false"))) != 0)
            {
                hv_Bold_COPY_INP_TMP = "medium";
            }
            else
            {
                hv_Exception = "Wrong value of control parameter Bold";
                throw new HalconException(hv_Exception);
            }
            if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("true"))) != 0)
            {
                if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("times"))) != 0)
                {
                    hv_Slant_COPY_INP_TMP = "i";
                }
                else
                {
                    hv_Slant_COPY_INP_TMP = "o";
                }
            }
            else if ((int)(new HTuple(hv_Slant_COPY_INP_TMP.TupleEqual("false"))) != 0)
            {
                hv_Slant_COPY_INP_TMP = "r";
            }
            else
            {
                hv_Exception = "Wrong value of control parameter Slant";
                throw new HalconException(hv_Exception);
            }
            try
            {
                HOperatorSet.SetFont(hv_ExpDefaultWinHandle, ((((((("-adobe-" + hv_Font_COPY_INP_TMP) + "-") + hv_Bold_COPY_INP_TMP) + "-") + hv_Slant_COPY_INP_TMP) + "-normal-*-") + hv_Size_COPY_INP_TMP) + "-*-*-*-*-*-*-*");
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                if ((int)((new HTuple(((hv_OS.TupleSubstr(0, 4))).TupleEqual("Linux"))).TupleAnd(
                    new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("courier")))) != 0)
                {
                    HOperatorSet.QueryFont(hv_ExpDefaultWinHandle, out hv_Fonts);
                    hv_FontSelRegexp = (("^-[^-]*-[^-]*[Cc]ourier[^-]*-" + hv_Bold_COPY_INP_TMP) + "-") + hv_Slant_COPY_INP_TMP;
                    hv_FontsCourier = ((hv_Fonts.TupleRegexpSelect(hv_FontSelRegexp))).TupleRegexpMatch(
                        hv_FontSelRegexp);
                    if ((int)(new HTuple((new HTuple(hv_FontsCourier.TupleLength())).TupleEqual(
                        0))) != 0)
                    {
                        hv_Exception = "Wrong font name";
                        //throw (Exception)
                    }
                    else
                    {
                        try
                        {
                            HOperatorSet.SetFont(hv_ExpDefaultWinHandle, (((hv_FontsCourier.TupleSelect(
                                0)) + "-normal-*-") + hv_Size_COPY_INP_TMP) + "-*-*-*-*-*-*-*");
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException2)
                        {
                            HDevExpDefaultException2.ToHTuple(out hv_Exception);
                            //throw (Exception)
                        }
                    }
                }
                //throw (Exception)
            }
        }
        // dev_set_preferences(...); only in hdevelop

        return;
    }

    // Chapter: Graphics / Text
    // Short Description: This procedure writes a text message. 
    public void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
        HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_Red = null, hv_Green = null, hv_Blue = null;
        HTuple hv_Row1Part = null, hv_Column1Part = null, hv_Row2Part = null;
        HTuple hv_Column2Part = null, hv_RowWin = null, hv_ColumnWin = null;
        HTuple hv_WidthWin = new HTuple(), hv_HeightWin = null;
        HTuple hv_MaxAscent = null, hv_MaxDescent = null, hv_MaxWidth = null;
        HTuple hv_MaxHeight = null, hv_R1 = new HTuple(), hv_C1 = new HTuple();
        HTuple hv_FactorRow = new HTuple(), hv_FactorColumn = new HTuple();
        HTuple hv_UseShadow = null, hv_ShadowColor = null, hv_Exception = new HTuple();
        HTuple hv_Width = new HTuple(), hv_Index = new HTuple();
        HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
        HTuple hv_W = new HTuple(), hv_H = new HTuple(), hv_FrameHeight = new HTuple();
        HTuple hv_FrameWidth = new HTuple(), hv_R2 = new HTuple();
        HTuple hv_C2 = new HTuple(), hv_DrawMode = new HTuple();
        HTuple hv_CurrentColor = new HTuple();
        HTuple hv_Box_COPY_INP_TMP = hv_Box.Clone();
        HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
        HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
        HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();
        HTuple hv_String_COPY_INP_TMP = hv_String.Clone();

        // Initialize local and output iconic variables 
        //This procedure displays text in a graphics window.
        //
        //Input parameters:
        //WindowHandle: The WindowHandle of the graphics window, where
        //   the message should be displayed
        //String: A tuple of strings containing the text message to be displayed
        //CoordSystem: If set to 'window', the text position is given
        //   with respect to the window coordinate system.
        //   If set to 'image', image coordinates are used.
        //   (This may be useful in zoomed images.)
        //Row: The row coordinate of the desired text position
        //   If set to -1, a default value of 12 is used.
        //Column: The column coordinate of the desired text position
        //   If set to -1, a default value of 12 is used.
        //Color: defines the color of the text as string.
        //   If set to [], '' or 'auto' the currently set color is used.
        //   If a tuple of strings is passed, the colors are used cyclically
        //   for each new textline.
        //Box: If Box[0] is set to 'true', the text is written within an orange box.
        //     If set to' false', no box is displayed.
        //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
        //       the text is written in a box of that color.
        //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
        //       'true' -> display a shadow in a default color
        //       'false' -> display no shadow (same as if no second value is given)
        //       otherwise -> use given string as color string for the shadow color
        //
        //Prepare window
        HOperatorSet.GetRgb(hv_ExpDefaultWinHandle, out hv_Red, out hv_Green, out hv_Blue);
        HOperatorSet.GetPart(hv_ExpDefaultWinHandle, out hv_Row1Part, out hv_Column1Part,
            out hv_Row2Part, out hv_Column2Part);
        HOperatorSet.GetWindowExtents(hv_ExpDefaultWinHandle, out hv_RowWin, out hv_ColumnWin,
            out hv_WidthWin, out hv_HeightWin);
        HOperatorSet.SetPart(hv_ExpDefaultWinHandle, 0, 0, hv_HeightWin - 1, hv_WidthWin - 1);
        //
        //default settings
        if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Row_COPY_INP_TMP = 12;
        }
        if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
        {
            hv_Column_COPY_INP_TMP = 12;
        }
        if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
        {
            hv_Color_COPY_INP_TMP = "";
        }
        //
        hv_String_COPY_INP_TMP = ((("" + hv_String_COPY_INP_TMP) + "")).TupleSplit("\n");
        //
        //Estimate extentions of text depending on font size.
        HOperatorSet.GetFontExtents(hv_ExpDefaultWinHandle, out hv_MaxAscent, out hv_MaxDescent,
            out hv_MaxWidth, out hv_MaxHeight);
        if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
        {
            hv_R1 = hv_Row_COPY_INP_TMP.Clone();
            hv_C1 = hv_Column_COPY_INP_TMP.Clone();
        }
        else
        {
            //Transform image to window coordinates
            hv_FactorRow = (1.0 * hv_HeightWin) / ((hv_Row2Part - hv_Row1Part) + 1);
            hv_FactorColumn = (1.0 * hv_WidthWin) / ((hv_Column2Part - hv_Column1Part) + 1);
            hv_R1 = ((hv_Row_COPY_INP_TMP - hv_Row1Part) + 0.5) * hv_FactorRow;
            hv_C1 = ((hv_Column_COPY_INP_TMP - hv_Column1Part) + 0.5) * hv_FactorColumn;
        }
        //
        //Display text box depending on text size
        hv_UseShadow = 1;
        hv_ShadowColor = "gray";
        if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleEqual("true"))) != 0)
        {
            if (hv_Box_COPY_INP_TMP == null)
                hv_Box_COPY_INP_TMP = new HTuple();
            hv_Box_COPY_INP_TMP[0] = "#fce9d4";
            hv_ShadowColor = "#f28d26";
        }
        if ((int)(new HTuple((new HTuple(hv_Box_COPY_INP_TMP.TupleLength())).TupleGreater(
            1))) != 0)
        {
            if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual("true"))) != 0)
            {
                //Use default ShadowColor set above
            }
            else if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(1))).TupleEqual(
                "false"))) != 0)
            {
                hv_UseShadow = 0;
            }
            else
            {
                hv_ShadowColor = hv_Box_COPY_INP_TMP[1];
                //Valid color?
                try
                {
                    HOperatorSet.SetColor(hv_ExpDefaultWinHandle, hv_Box_COPY_INP_TMP.TupleSelect(
                        1));
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_Exception = "Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)";
                    throw new HalconException(hv_Exception);
                }
            }
        }
        if ((int)(new HTuple(((hv_Box_COPY_INP_TMP.TupleSelect(0))).TupleNotEqual("false"))) != 0)
        {
            //Valid color?
            try
            {
                HOperatorSet.SetColor(hv_ExpDefaultWinHandle, hv_Box_COPY_INP_TMP.TupleSelect(
                    0));
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                hv_Exception = "Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)";
                throw new HalconException(hv_Exception);
            }
            //Calculate box extents
            hv_String_COPY_INP_TMP = (" " + hv_String_COPY_INP_TMP) + " ";
            hv_Width = new HTuple();
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                HOperatorSet.GetStringExtents(hv_ExpDefaultWinHandle, hv_String_COPY_INP_TMP.TupleSelect(
                    hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
                hv_Width = hv_Width.TupleConcat(hv_W);
            }
            hv_FrameHeight = hv_MaxHeight * (new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                ));
            hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
            hv_R2 = hv_R1 + hv_FrameHeight;
            hv_C2 = hv_C1 + hv_FrameWidth;
            //Display rectangles
            HOperatorSet.GetDraw(hv_ExpDefaultWinHandle, out hv_DrawMode);
            HOperatorSet.SetDraw(hv_ExpDefaultWinHandle, "fill");
            //Set shadow color
            HOperatorSet.SetColor(hv_ExpDefaultWinHandle, hv_ShadowColor);
            if ((int)(hv_UseShadow) != 0)
            {
                HOperatorSet.DispRectangle1(hv_ExpDefaultWinHandle, hv_R1 + 1, hv_C1 + 1, hv_R2 + 1,
                    hv_C2 + 1);
            }
            //Set box color
            HOperatorSet.SetColor(hv_ExpDefaultWinHandle, hv_Box_COPY_INP_TMP.TupleSelect(
                0));
            HOperatorSet.DispRectangle1(hv_ExpDefaultWinHandle, hv_R1, hv_C1, hv_R2, hv_C2);
            HOperatorSet.SetDraw(hv_ExpDefaultWinHandle, hv_DrawMode);
        }
        //Write text.
        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
            )) - 1); hv_Index = (int)hv_Index + 1)
        {
            hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index % (new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
                )));
            if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
                "auto")))) != 0)
            {
                HOperatorSet.SetColor(hv_ExpDefaultWinHandle, hv_CurrentColor);
            }
            else
            {
                HOperatorSet.SetRgb(hv_ExpDefaultWinHandle, hv_Red, hv_Green, hv_Blue);
            }
            hv_Row_COPY_INP_TMP = hv_R1 + (hv_MaxHeight * hv_Index);
            HOperatorSet.SetTposition(hv_ExpDefaultWinHandle, hv_Row_COPY_INP_TMP, hv_C1);
            HOperatorSet.WriteString(hv_ExpDefaultWinHandle, hv_String_COPY_INP_TMP.TupleSelect(
                hv_Index));
        }
        //Reset changed window settings
        HOperatorSet.SetRgb(hv_ExpDefaultWinHandle, hv_Red, hv_Green, hv_Blue);
        HOperatorSet.SetPart(hv_ExpDefaultWinHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part,
            hv_Column2Part);

        return;
    }

    public void p_disp_edge_marker(HTuple hv_Row, HTuple hv_Col, HTuple hv_Phi, HTuple hv_Length,
     HTuple hv_Color, HTuple hv_LineWidth, HTuple hv_WindowHandle)
    {



        // Local iconic variables 

        HObject ho_Marker;

        // Local control variables 

        HTuple hv_RowStart = null, hv_RowEnd = null;
        HTuple hv_ColStart = null, hv_ColEnd = null;
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_Marker);
        try
        {
            //Determine start and end point of the edge marker.
            hv_RowStart = hv_Row + (hv_Length * (hv_Phi.TupleCos()));
            hv_RowEnd = hv_Row - (hv_Length * (hv_Phi.TupleCos()));
            hv_ColStart = hv_Col + (hv_Length * (hv_Phi.TupleSin()));
            hv_ColEnd = hv_Col - (hv_Length * (hv_Phi.TupleSin()));
            //
            //Generate a contour that connects the start and end point.
            ho_Marker.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_Marker, hv_RowStart.TupleConcat(hv_RowEnd),
                hv_ColStart.TupleConcat(hv_ColEnd));
            //
            //Display the contour with  the specified style.
            HOperatorSet.SetColor(hv_ExpDefaultWinHandle, hv_Color);
            HOperatorSet.SetLineWidth(hv_ExpDefaultWinHandle, hv_LineWidth);
            HOperatorSet.DispObj(ho_Marker, hv_ExpDefaultWinHandle);
            //
            //Reset the line width.
            HOperatorSet.SetLineWidth(hv_ExpDefaultWinHandle, 1);
            ho_Marker.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Marker.Dispose();

            throw HDevExpDefaultException;
        }
    }

    public void p_disp_dimensions(HTuple hv_RowEdgeFirst, HTuple hv_ColumnEdgeFirst,
    HTuple hv_RowEdgeSecond, HTuple hv_ColumnEdgeSecond, HTuple hv_IntraDistance,
    HTuple hv_InterDistance, HTuple hv_Phi, HTuple hv_Length, HTuple hv_WindowHandle)
    {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_Number = null, hv_i = null, hv_Text = new HTuple();
        // Initialize local and output iconic variables 
        //Loop over all edge pairs.
        hv_Number = new HTuple(hv_RowEdgeFirst.TupleLength());
        HTuple end_val2 = hv_Number - 1;
        HTuple step_val2 = 1;
        for (hv_i = 0; hv_i.Continue(end_val2, step_val2); hv_i = hv_i.TupleAdd(step_val2))
        {
            //
            //Display markers for the edges.
            p_disp_edge_marker(hv_RowEdgeFirst.TupleSelect(hv_i), hv_ColumnEdgeFirst.TupleSelect(
                hv_i), hv_Phi, hv_Length, "#FF00FF", 2, hv_WindowHandle);
            p_disp_edge_marker(hv_RowEdgeSecond.TupleSelect(hv_i), hv_ColumnEdgeSecond.TupleSelect(
                hv_i), hv_Phi, hv_Length, "#00FFFF", 2, hv_WindowHandle);
            //
            //Display the IntraDistance between the edges.
            hv_Text = hv_IntraDistance.TupleSelect(hv_i);
            p_disp_text_right_of_center(hv_WindowHandle, hv_Text.TupleString(".2f"), hv_RowEdgeFirst.TupleSelect(
                hv_i), hv_ColumnEdgeFirst.TupleSelect(hv_i), hv_RowEdgeSecond.TupleSelect(
                hv_i), hv_ColumnEdgeSecond.TupleSelect(hv_i), hv_Phi, 2.0 * hv_Length);
        }
        //
        //Loop to display the distance between the edge pairs.
        HTuple end_val14 = hv_Number - 2;
        HTuple step_val14 = 1;
        for (hv_i = 0; hv_i.Continue(end_val14, step_val14); hv_i = hv_i.TupleAdd(step_val14))
        {
            //
            //Display the InterDistance between the edge pairs.
            hv_Text = hv_InterDistance.TupleSelect(hv_i);
            p_disp_text_left_of_center(hv_WindowHandle, hv_Text.TupleString(".2f"), hv_RowEdgeSecond.TupleSelect(
                hv_i), hv_ColumnEdgeSecond.TupleSelect(hv_i), hv_RowEdgeFirst.TupleSelect(
                hv_i + 1), hv_ColumnEdgeFirst.TupleSelect(hv_i + 1), hv_Phi, 2.0 * hv_Length);
        }

        return;
    }

    public void p_disp_text_right_of_center(HTuple hv_WindowHandle, HTuple hv_Text,
     HTuple hv_RowFirst, HTuple hv_ColFirst, HTuple hv_RowSecond, HTuple hv_ColSecond,
     HTuple hv_Phi, HTuple hv_Distance)
    {

        HTuple hv_Row1Part = null, hv_Column1Part = null;
        HTuple hv_Row2Part = null, hv_Column2Part = null, hv_RowWin = null;
        HTuple hv_ColumnWin = null, hv_WidthWin = new HTuple();
        HTuple hv_HeightWin = null, hv_FactorRow = null, hv_FactorColumn = null;
        HTuple hv_Ascent = null, hv_Descent = null, hv_Width = null;
        HTuple hv_Height = null, hv_RowCenter = null, hv_ColCenter = null;
        HTuple hv_RowPos = null, hv_ColPos = null, hv_RowText = null;
        HTuple hv_ColText = null;
        HTuple hv_Distance_COPY_INP_TMP = hv_Distance.Clone();

        // Initialize local and output iconic variables 
        //Determine factors for the adaptation of the string extents that might be necessary
        //because of image zooming.
        HOperatorSet.GetPart(hv_ExpDefaultWinHandle, out hv_Row1Part, out hv_Column1Part,
            out hv_Row2Part, out hv_Column2Part);
        HOperatorSet.GetWindowExtents(hv_ExpDefaultWinHandle, out hv_RowWin, out hv_ColumnWin,
            out hv_WidthWin, out hv_HeightWin);
        hv_FactorRow = (1.0 * ((hv_Row2Part - hv_Row1Part) + 1)) / hv_HeightWin;
        hv_FactorColumn = (1.0 * ((hv_Column2Part - hv_Column1Part) + 1)) / hv_WidthWin;
        //
        //Determine the extent of the string and its position.
        HOperatorSet.GetStringExtents(hv_ExpDefaultWinHandle, hv_Text, out hv_Ascent,
            out hv_Descent, out hv_Width, out hv_Height);
        hv_Width = hv_Width * hv_FactorColumn;
        hv_Height = hv_Height * hv_FactorRow;
        hv_RowCenter = (hv_RowFirst + hv_RowSecond) / 2.0;
        hv_ColCenter = (hv_ColFirst + hv_ColSecond) / 2.0;
        if ((int)(new HTuple(((hv_Phi.TupleSin())).TupleLess(0))) != 0)
        {
            hv_Distance_COPY_INP_TMP = -hv_Distance_COPY_INP_TMP;
        }
        hv_RowPos = hv_RowCenter + (hv_Distance_COPY_INP_TMP * (hv_Phi.TupleCos()));
        hv_ColPos = hv_ColCenter + (hv_Distance_COPY_INP_TMP * (hv_Phi.TupleSin()));
        hv_RowText = hv_RowPos - (hv_Height / 2.0);
        hv_ColText = hv_ColPos.Clone();
        //
        //Set the text position and color and display the text.
        HOperatorSet.SetTposition(hv_ExpDefaultWinHandle, hv_RowText, hv_ColText);
        HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "#FF00FF");
        HOperatorSet.WriteString(hv_ExpDefaultWinHandle, hv_Text);

        return;
    }

    // Short Description: Displays text right of the center of two given points. 
    public void p_disp_text_left_of_center(HTuple hv_WindowHandle, HTuple hv_Text,
        HTuple hv_RowFirst, HTuple hv_ColFirst, HTuple hv_RowSecond, HTuple hv_ColSecond,
        HTuple hv_Phi, HTuple hv_Distance)
    {

        HTuple hv_Row1Part = null, hv_Column1Part = null;
        HTuple hv_Row2Part = null, hv_Column2Part = null, hv_RowWin = null;
        HTuple hv_ColumnWin = null, hv_WidthWin = new HTuple();
        HTuple hv_HeightWin = null, hv_FactorRow = null, hv_FactorColumn = null;
        HTuple hv_Ascent = null, hv_Descent = null, hv_Width = null;
        HTuple hv_Height = null, hv_RowCenter = null, hv_ColCenter = null;
        HTuple hv_RowPos = null, hv_ColPos = null, hv_RowText = null;
        HTuple hv_ColText = null;
        HTuple hv_Distance_COPY_INP_TMP = hv_Distance.Clone();

        // Initialize local and output iconic variables 
        //Determine factors for the adaptation of the string extents that might be necessary
        //because of image zooming.
        HOperatorSet.GetPart(hv_ExpDefaultWinHandle, out hv_Row1Part, out hv_Column1Part,
            out hv_Row2Part, out hv_Column2Part);
        HOperatorSet.GetWindowExtents(hv_ExpDefaultWinHandle, out hv_RowWin, out hv_ColumnWin,
            out hv_WidthWin, out hv_HeightWin);
        hv_FactorRow = (1.0 * ((hv_Row2Part - hv_Row1Part) + 1)) / hv_HeightWin;
        hv_FactorColumn = (1.0 * ((hv_Column2Part - hv_Column1Part) + 1)) / hv_WidthWin;
        //
        //Determine the extent of the string and its position.
        HOperatorSet.GetStringExtents(hv_ExpDefaultWinHandle, hv_Text, out hv_Ascent,
            out hv_Descent, out hv_Width, out hv_Height);
        hv_Width = hv_Width * hv_FactorColumn;
        hv_Height = hv_Height * hv_FactorRow;
        hv_RowCenter = (hv_RowFirst + hv_RowSecond) / 2.0;
        hv_ColCenter = (hv_ColFirst + hv_ColSecond) / 2.0;
        if ((int)(new HTuple(((hv_Phi.TupleSin())).TupleLess(0))) != 0)
        {
            hv_Distance_COPY_INP_TMP = -hv_Distance_COPY_INP_TMP;
        }
        hv_RowPos = hv_RowCenter - (hv_Distance_COPY_INP_TMP * (hv_Phi.TupleCos()));
        hv_ColPos = hv_ColCenter - (hv_Distance_COPY_INP_TMP * (hv_Phi.TupleSin()));
        hv_RowText = hv_RowPos - (hv_Height / 2.0);
        hv_ColText = hv_ColPos - hv_Width;
        //
        //Set the text position and color and display the text.
        HOperatorSet.SetTposition(hv_ExpDefaultWinHandle, hv_RowText, hv_ColText);
        HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "black");
        HOperatorSet.WriteString(hv_ExpDefaultWinHandle, hv_Text);

        return;
    }

    public string Measure_Diameter(HObject ho_Image, HTuple hv_Row, HTuple hv_Column, HTuple hv_Phi, HTuple hv_Length1, HTuple hv_Length2, HTuple Window,double dmin = 20,double dmax=200)
    {
        bool isOK = false;
        HObject ho_Rectangle;
        HTuple hv_Width = null, hv_Height = null, hv_WindowHandle = new HTuple();
        HTuple hv_MeasureHandle = null, hv_Sigma = null, hv_Threshold = null;
        HTuple hv_Transition = null, hv_Select = null, hv_RowEdgeFirst = null;
        HTuple hv_ColumnEdgeFirst = null, hv_AmplitudeFirst = null;
        HTuple hv_RowEdgeSecond = null, hv_ColumnEdgeSecond = null;
        HTuple hv_AmplitudeSecond = null, hv_IntraDistance = null;
        HTuple hv_InterDistance = null;
        // Initialize local and output iconic variables 
      
        HOperatorSet.GenEmptyObj(out ho_Rectangle);
        try
        {
            hv_ExpDefaultWinHandle = Window;
            HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "#FF00FF");
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            set_display_font(hv_ExpDefaultWinHandle, 16, "mono", "true", "false");
            HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);
            HOperatorSet.GenMeasureRectangle2(hv_Row, hv_Column, hv_Phi, hv_Length1, hv_Length2,
                hv_Width, hv_Height, "nearest_neighbor", out hv_MeasureHandle);
            hv_Sigma = 0.9;
            hv_Threshold = 12;
            hv_Transition = "negative";
            hv_Select = "all";
            HOperatorSet.MeasurePairs(ho_Image, hv_MeasureHandle, hv_Sigma, hv_Threshold,
                hv_Transition, hv_Select, out hv_RowEdgeFirst, out hv_ColumnEdgeFirst,
                out hv_AmplitudeFirst, out hv_RowEdgeSecond, out hv_ColumnEdgeSecond, out hv_AmplitudeSecond,
                out hv_IntraDistance, out hv_InterDistance);

            HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);
            HOperatorSet.SetDraw(hv_ExpDefaultWinHandle, "margin");
            HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "#FF00FF");
            ho_Rectangle.Dispose();
            HOperatorSet.GenRectangle2(out ho_Rectangle, hv_Row, hv_Column, hv_Phi, hv_Length1,
                hv_Length2);
            p_disp_dimensions(hv_RowEdgeFirst, hv_ColumnEdgeFirst, hv_RowEdgeSecond, hv_ColumnEdgeSecond,
                hv_IntraDistance, hv_InterDistance, hv_Phi, hv_Length2, hv_WindowHandle);
            if ((hv_IntraDistance > dmin) && (hv_IntraDistance < dmax))
                isOK = true;
            else
                isOK = false;
            /*
            HOperatorSet.CreateFunct1dPairs(((new HTuple(7)).TupleConcat(9)).TupleConcat(
                11), ((new HTuple(0.0)).TupleConcat(1.0)).TupleConcat(0.0), out hv_SizeFunction);
            //
            //Then, expand the measure to a fuzzy measure that will return only pairs of approximately the given size.
            hv_SetType = "size";
            HOperatorSet.SetFuzzyMeasure(hv_MeasureHandle, hv_SetType, hv_SizeFunction);
            //
            //Finally, determine all edge pairs that have a negative transition and approximately the given size.
            hv_Sigma = 0.9;
            hv_AmpThresh = 12;
            hv_FuzzyThresh = 0.5;
            hv_Transition = "negative";
            HOperatorSet.FuzzyMeasurePairs(ho_Image, hv_MeasureHandle, hv_Sigma, hv_AmpThresh,
                hv_FuzzyThresh, hv_Transition, out hv_RowEdgeFirst, out hv_ColumnEdgeFirst,
                out hv_AmplitudeFirst, out hv_RowEdgeSecond, out hv_ColumnEdgeSecond, out hv_AmplitudeSecond,
                out hv_RowEdgeCenter, out hv_ColumnEdgeCenter, out hv_FuzzyScore, out hv_IntraDistance,
                out hv_InterDistance);
            //
            //And again, visualize the results
            HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);
            HOperatorSet.SetDraw(hv_ExpDefaultWinHandle, "margin");
            HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "#FF00FF");
            ho_Rectangle.Dispose();
            HOperatorSet.GenRectangle2(out ho_Rectangle, hv_Row, hv_Column, hv_Phi, hv_Length1,
                hv_Length2);
            p_disp_dimensions(hv_RowEdgeFirst, hv_ColumnEdgeFirst, hv_RowEdgeSecond, hv_ColumnEdgeSecond,
                hv_IntraDistance, hv_InterDistance, hv_Phi, hv_Length2, hv_WindowHandle);
            disp_message(hv_ExpDefaultWinHandle, "Fuzzy measure results", "window", 12,
                12, "blue", "true");
                */
            HOperatorSet.CloseMeasure(hv_MeasureHandle);
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho_Image.Dispose();
            ho_Rectangle.Dispose();
            throw HDevExpDefaultException;
        }
       // ho_Image.Dispose();
        ho_Rectangle.Dispose();
        if (isOK)
            return "OK";
        else
            return "NG";
    }

    public double Disp_Adjust_Line(HObject ho_Image1,HTuple hv_row, HTuple hv_column, HTuple hv_angle, HTuple hv_length1, HTuple hv_length2, HTuple Window, bool isDisp = true) {
        try
        {
            hv_ExpDefaultWinHandle = Window;
            HObject ho_Rectangle, ho_red, ho_green;
            HObject ho_blue, ho_ImageGray, ho_ImageReduced, ho_Border;
            HObject ho_UnionContours, ho_RegionLines, ho_ImageRotated;

            HTuple hv_Width = null, hv_Height = null;
            HTuple hv_RowBegin = null, hv_ColBegin = null;
            HTuple hv_RowEnd = null, hv_ColEnd = null, hv_Nr = null;
            HTuple hv_Nc = null, hv_Dist = null, hv_Angle = null, hv_a = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            HOperatorSet.GenEmptyObj(out ho_red);
            HOperatorSet.GenEmptyObj(out ho_green);
            HOperatorSet.GenEmptyObj(out ho_blue);
            HOperatorSet.GenEmptyObj(out ho_ImageGray);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_Border);
            HOperatorSet.GenEmptyObj(out ho_UnionContours);
            HOperatorSet.GenEmptyObj(out ho_RegionLines);
            HOperatorSet.GenEmptyObj(out ho_ImageRotated);

            HOperatorSet.GetImageSize(ho_Image1, out hv_Width, out hv_Height);
            HOperatorSet.SetDraw(hv_ExpDefaultWinHandle, "margin");
            HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "#FF00FF");
            ho_Rectangle.Dispose();
            HOperatorSet.GenRectangle2(out ho_Rectangle, hv_row, hv_column, hv_angle, hv_length1,hv_length2);
            HOperatorSet.DispObj(ho_Rectangle, hv_ExpDefaultWinHandle);
            ho_red.Dispose(); ho_green.Dispose(); ho_blue.Dispose();
            //HOperatorSet.Decompose3(ho_Image1, out ho_red, out ho_green, out ho_blue);
            ho_ImageGray.Dispose();
            //HOperatorSet.Rgb3ToGray(ho_red, ho_green, ho_blue, out ho_ImageGray);
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho_Image1, ho_Rectangle, out ho_ImageReduced);
            ho_Border.Dispose();
            HOperatorSet.ThresholdSubPix(ho_ImageReduced, out ho_Border, 200);

            HOperatorSet.DispObj(ho_Border, hv_ExpDefaultWinHandle);

            Console.WriteLine("ooop");

            ho_UnionContours.Dispose();
            HOperatorSet.UnionCollinearContoursXld(ho_Border, out ho_UnionContours, 5, 1,
                2, 0.1, "attr_keep");
            HOperatorSet.FitLineContourXld(ho_UnionContours, "tukey", -1, 0, 5, 2, out hv_RowBegin,
                out hv_ColBegin, out hv_RowEnd, out hv_ColEnd, out hv_Nr, out hv_Nc, out hv_Dist);
            ho_RegionLines.Dispose();
            
            HOperatorSet.GenRegionLine(out ho_RegionLines, hv_RowBegin, hv_ColBegin, hv_RowEnd,
                hv_ColEnd);
           
            HOperatorSet.AngleLx(hv_RowEnd, hv_ColEnd, hv_RowBegin, hv_ColBegin, out hv_Angle);
            hv_a = 270 - (((hv_Angle.TupleSelect(0)) * 360) / (2 * 3.141592654));
            ho_ImageRotated.Dispose();
            HOperatorSet.RotateImage(ho_Image1, out ho_ImageRotated, hv_a, "constant");

            if (isDisp)
            {
                action(ho_Image1);
                HOperatorSet.DispObj(ho_ImageRotated, hv_ExpDefaultWinHandle);
                HOperatorSet.DispObj(ho_RegionLines, hv_ExpDefaultWinHandle);
                HOperatorSet.DispObj(ho_Rectangle, hv_ExpDefaultWinHandle);
                //ho_Image1.Dispose();
                ho_Rectangle.Dispose();
                ho_red.Dispose();
                ho_green.Dispose();
                ho_blue.Dispose();
                ho_ImageGray.Dispose();
                ho_ImageReduced.Dispose();
                ho_Border.Dispose();
                ho_UnionContours.Dispose();
                ho_RegionLines.Dispose();
                ho_ImageRotated.Dispose();
            }
            return (double)hv_a;
        }
        catch (HalconException ex)
        {
           throw ex;
        }
    }


    public string check_axis(HObject ho_Image,HTuple Window) {
        try
        {
            hv_ExpDefaultWinHandle = Window;
            action(ho_Image);

            return "OK";
        }
        catch (HalconException ex)
        {
            throw ex;
        }
    }

    public string check_gear(HObject ho_Image, HTuple Window)
    {
        try
        {
            hv_ExpDefaultWinHandle = Window;
            action(ho_Image);

            return "OK";
        }
        catch (HalconException ex)
        {
            throw ex;
        }
    }

    public void InitHalcon(int width = 512, int height = 512)
    {
        // Default settings used in HDevelop 
        HOperatorSet.SetSystem("width", width);
        HOperatorSet.SetSystem("height", height);
    }





    public void RunHalcon(HTuple Window, HObject ho_Image)
    {
        try
        {
            hv_ExpDefaultWinHandle = Window;
            action(ho_Image);
        }
        catch (HalconException e)
        {
            throw e;
        }
    }

}

